# Testing Smart Contracts with Truffle

- Build Artifacts
    - ìŠ¤ë§ˆíŠ¸ì»¨íŠ¸ë™íŠ¸ë¥¼ ì»´íŒŒì¼í•  ë•Œ ë§ˆë‹¤, ì†”ë¦¬ë””í‹° ì»´íŒŒì¼ëŸ¬ëŠ” ê·¸ ì»¨íŠ¸ë™íŠ¸ì˜ binary í˜•íƒœë¥¼ í¬í•¨í•˜ëŠ” JSON(build artifact)íŒŒì¼ì„ ë§Œë“¤ê³  build/contracts í´ë”ì— ì €ì¥í•œë‹¤.
    - migrationì„ í• ë•Œ Truffleì€ ê·¸ ë„¤íŠ¸ì›Œí¬ê³¼ ì—°ê´€ëœ ì •ë³´ë¥¼ ì´ íŒŒì¼ì— ì—…ë°ì´íŠ¸ í•œë‹¤.
    - ìƒˆë¡œìš´ í…ŒìŠ¤íŠ¸ë¥¼ ë§Œë“¤ì–´ ë‚¼ë•Œë§ˆë‹¤ í•„ìš”í•œ ì²«ë²ˆì§¸ ì‘ì—…ì€ ìƒí˜¸ì‘ìš©í•˜ê¸¸ ì›í•˜ëŠ” ì»¨íŠ¸ë™íŠ¸ì˜ build artifactsë¥¼ ë¡œë“œí•˜ëŠ” ê²ƒì´ë‹¤. ì´ë•Œ, Truffleì€ ì»¨íŠ¸ë™íŠ¸ë¥¼ ì´í•´í•˜ê¸° ìœ„í•œ ë°©ë²•ìœ¼ë¡œ ì–´ë–»ê²Œ í•¨ìˆ˜ë“¤ì„ formatí•˜ê³  callí•˜ëŠ”ì§€ ì•Œë ¤ì¤€ë‹¤.
        
        ```jsx
        const myAwesomeContract = artifacts.require("myAwesomeContract");
        ```
        
        ì´ í•¨ìˆ˜ëŠ” contract abstractionì„ ë¦¬í„´í•œë‹¤.  contract abstractionì€ ì´ë”ë¦¬ì›€ê³¼ ìƒí˜¸ì‘ìš©í•˜ëŠ” ë³µì¡í•¨ì„ í•´ì†Œí•˜ê³  ìë°”ìŠ¤í¬ë¦½íŠ¸ì˜ í¸ë¦¬í•¨ì„ ì†”ë¦¬ë””í‹° ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì— ì œê³µí•œë‹¤. 
        
    
- The contract() function

í…ŒìŠ¤íŠ¸ë¥¼ ê°„í¸í•˜ê²Œ ë§Œë“¤ê¸° ìœ„í•´ì„œ Truffleì€  Mocha ì£¼ë³€ì— ê°„ë‹¨í•œ wrapperë¥¼ ì¶”ê°€í•œë‹¤.

- group tests : contract()ë¼ëŠ” í•¨ìˆ˜ë¥¼ ë¶ˆëŸ¬ì„œ ê·¸ë£¹ì„ í…ŒìŠ¤íŠ¸ í•œë‹¤. ì´ê²ƒì€ í…ŒìŠ¤íŠ¸ë‚˜ cleanupì„ ì‹¤í–‰í•˜ê¸° ìœ„í•´ ê³„ì •ë“¤ì˜ ë¦¬ìŠ¤íŠ¸ë¥¼ ì œê³µí•¨ìœ¼ë¡œì¨ Mochaì˜ describe()ë¥¼ í™•ì¥ì‹œí‚¨ë‹¤.
    
    â‡’ contract()ëŠ” ë‘ê°œì˜ ì¸ìë¥¼ ê°–ëŠ”ë‹¤.
    
    1. string / ë¬´ì—‡ì„ í…ŒìŠ¤íŠ¸ í• ê²ƒì¸ì§€ ë°˜ë“œì‹œ ë‚˜íƒ€ë‚´ì•¼ í•œë‹¤.
    2. callback / ì‹¤ì œ í…ŒìŠ¤íŠ¸ì—ì„œ ì–´ë””ì— ê¸°ë¡í•  ê²ƒì¸ì§€ë¥¼ ë°˜ìŠ¤ì‹œ ì¨ì•¼í•œë‹¤.
- exectue them : it()ì´ë¼ëŠ” í•¨ìˆ˜ë¥¼ ë¶ˆëŸ¬ì„œ ì‹¤í–‰ì‹œí‚¨ë‹¤.
    
    â‡’ it() ë˜í•œ ë‘ê°œì˜ ì¸ìë¥¼ ê°–ëŠ”ë‹¤.
    
    1. string : ì‹¤ì œ ë¬´ì—‡ì„ í…ŒìŠ¤íŠ¸ í•  ê²ƒì¸ì§€ ì„¤ëª…í•œë‹¤.
    2. callback 
    
    ```jsx
    contract("MyAwesomeContract", (accounts) => {
    	it("should be able to receive Ethers", ()=> {
    	})
    })
    ```
    
    <aside>
    ğŸ’¡ ì˜ ì§œì—¬ì§„ í…ŒìŠ¤íŠ¸ëŠ” ì‹¤ì œ ì½”ë“œê°€ ë¬´ì—‡ì„ í•˜ëŠ”ì§€ ì„¤ëª…í•œë‹¤. test suitì™€ test caseì˜  ì„¤ëª…ì´ ì¼ê´€ì„±ìˆëŠ” ë¬¸ì¥ìœ¼ë¡œì¨ í•¨ê»˜ ì½í ìˆ˜ ìˆë„ë¡ ì‘ì„±í•´ì•¼í•œë‹¤.
    
    </aside>
    

## The First Test

ì´ë”ë¦¬ì›€ì— ë°°í¬í•˜ê¸° ì „ì— ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¥¼ localì—ì„œ í…ŒìŠ¤íŠ¸ í•˜ëŠ”ê²ƒì€ ê°€ì¥ ì¢‹ì€ ë°©ë²•ì„ â‡’ Ganacheë¥¼ ì‚¬ìš©í•´ì„œ í…ŒìŠ¤í•  ìˆ˜ ìˆìŒ (Ganache : ë¡œì»¬ ì´ë”ë¦¬ì›€ ë„¤íŠ¸ì›Œí¬ë¥¼ ì œê³µ)

- Ganache

ganacheë¥¼ ì‹¤í–‰í•  ë•Œ ë§ˆë‹¤ 10ê°œì˜ í…ŒìŠ¤íŠ¸ ê³„ì •ì„ ìƒì„±í•˜ê³ , ì´ê²ƒì€ í…ŒìŠ¤íŠ¸ë¥¼ ì‰½ê²Œ í•˜ë„ë¡ ê° ê³„ì •ì— 100ETHë¥¼ ì¤Œ. 

ganacheì™€ Truffleì€ ê°•í•˜ê²Œ í†µí•©ë˜ì–´ ìˆê¸° ë•Œë¬¸ì— accounts ë°°ì—´ì„ í†µí•´ì„œ ì´ ê³„ì •ë“¤ì— ì ‘ê·¼í•  ìˆ˜ ìˆìŒ.

accounts[0]ê³¼ acconts[1]ë“±ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì€ í…ŒìŠ¤íŠ¸ì˜ ê°€ë…ì„±ì„ ë–¨ì–´ëœ¨ë¦¼. ë”°ë¼ì„œ ì´ˆê¸°í™” ì‹œì¼œì£¼ëŠ”ê³¼ì •ì„ í•˜ê²Œë¨

```jsx
let [alice, bob] = accounts;
```

<aside>
ğŸ’¡ aliceì™€ bobì¸ ì´ìœ ?
Aliceì™€ Bob, ì¦‰ A and Bì˜ ì´ë¦„ì€ ì•”í˜¸í•™, ë¬¼ë¦¬í•™, í”„ë¡œê·¸ë˜ë°ì—ì„œ ìì£¼ ì‚¬ìš©ë˜ëŠ” ì´ë¦„ìœ¼ë¡œ ì˜¤ë˜ëœ ê´€ìŠµì„.

</aside>

- Creating a New Zombie

ì•¨ë¦¬ìŠ¤ëŠ” ì¢€ë¹„ê²Œì„ì„ í•˜ê¸° ìœ„í•´ ì²«ë²ˆì§¸ë¡œ ê·¸ë…€ì˜ ì¢€ë¹„ë¥¼ ë§Œë“¤ì–´ì•¼ í•œë‹¤.

ê·¸ë ‡ê²Œ í•˜ê¸°ìœ„í•´ì„œ í”„ë¡ íŠ¸ì—”ë“œ(ì¦‰, ì—¬ê¸°ì„œëŠ” íŠ¸ëŸ¬í”Œ)ê°€ createRandomZombie í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•´ì•¼í•œë‹¤.

```solidity
function createRandomZombie (string _name) public {
	require(ownerZombieCount[msg.sender] == 0 );
	uint randDna = _generateRandomDna(_name);
	randDna = randDna = randDna % 100;
	_createZombie(_name, randDna);
}
```

 â‡’ ì´ì „ ì»¨íŠ¸ë™íŠ¸ì—ì„œ createRandomZombie ì½”ë“œ

```solidity
const CryptoZombies = artifacts.require("CryptoZombies");
contract("CryptoZombies", (accounts) => {
    let [alice, bob] = accounts;
    it("should be able to create a new zombie", async () => {   
})
```

â‡’ ë‘ë²ˆì§¸ ì¸ì, ì¦‰ callback í•¨ìˆ˜ëŠ” ë¸”ë¡ì²´ì¸ê³¼ ì†Œí†µí•˜ê¸° ìœ„í•œê²ƒì„. ì´ê²ƒì€ callbackí•¨ìˆ˜ê°€ ë¹„ë™ê¸°, asyn(asynchronous)ì„ì„ ì˜ë¯¸í•¨. asynì„ ì¨ì¤Œìœ¼ë¡œì¨ ì´ í•¨ìˆ˜ëŠ” awaitì„ í•¨ê»˜ ë¶€ë¥´ê²Œ ë˜ê³  í…ŒìŠ¤íŠ¸ëŠ” returnê¹Œì§€ ê¸°ë‹¤ë¦¬ê²Œ ëœë‹¤.

- í…ŒìŠ¤íŠ¸ì— í¬í•¨ë˜ëŠ” ê²ƒë“¤
    1. set up : ì´ˆê¸° ìƒíƒœë‚˜ ì…ë ¥ê°’ì„ ì´ˆê¸°í™” í• ë•Œ ì‚¬ìš©
    2. act : ì‹¤ì œ ì½”ë“œë¥¼ í…ŒìŠ¤íŠ¸ í•˜ëŠ” ìœ„ì¹˜. (ì˜¤ì§ í•˜ë‚˜ì˜ í…ŒìŠ¤íŠ¸ ë§Œì„ ì‹¤í–‰)
    3. assert : ê²°ê³¼ê°’ ì²´í¬
- set up
    
    chapter2ì—ì„œ contract abstractionì„ ë§Œë“¤ì—ˆì§€ë§Œ, ì´ê²ƒì„ ë§ ê·¸ëŒ€ë¡œ ì¶”ìƒì ì´ë‹¤. ì´ê²ƒì„ ì‹¤ì œë¡œ ìŠ¤ë§ˆíŠ¸ì»¨íŠ¸ë™íŠ¸ì™€ ìƒí˜¸ì‘ìš© í•˜ë„ë¡ ë§Œë“¤ê¸° ìœ„í•´ì„œ ì»¨íŠ¸ë™íŠ¸ instanceë¡œì„œ ì‘ìš©í•˜ëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ ê°ì²´ë¥¼ ë§Œë“¤ì–´ì•¼ í•¨.
    
    ìœ„ì— ë‚˜ì˜¨ myAwesomeContractì˜ ì˜ˆì‹œë¥¼ ê³„ì† í•¨ìœ¼ë¡œì¨ contract abstractionì„ instanceë¥¼ ì´ˆê¸°í™” í•˜ëŠ”ë° ì‚¬ìš©í•  ìˆ˜ ìˆìŒ
    
    ```solidity
    const contractInstance = await myAwesomeContract.new();
    ```
    
- Act
    
    truffleì˜ íŠ¹ì„± ì¤‘ í•œê°€ì§€ëŠ” ì˜¤ë¦¬ì§€ë„ ì†”ë¦¬ë””í‹° implementationì„ wrapí•˜ê³  ìš°ë¦¬ê°€ ì¸ìë¡œì„œ ì£¼ì†Œë¥¼ ë„˜ê¹€ìœ¼ë¡œì¨ í•¨ìˆ˜ë¥¼ ë§Œë“œëŠ” ì£¼ì†Œë¥¼ êµ¬ì²´í™” í•˜ë„ë¡ ë§Œë“ ë‹¤.
    
    ë‹¤ìŒì€ createRandomZombieë¥¼ ë¶€ë¥´ê³  msg.senderë¥¼ aliceì˜ ì£¼ì†Œë¡œ ì„¤ì •í•œë‹¤.
    
    ```jsx
    const result = await contractInstance.createRandomZombie(zombieNames[0], {from : alice});
    ```
    
    ê·¸ëŸ¬ë©´ ë¬´ì—‡ì„ resultì— ì €ì¥í–ˆëŠ”ì§€ ì•Œ ìˆ˜ ìˆì„ê¹Œ?
    
    â‡’ Log and Events
    
    artifacts.requireì„ ì‚¬ìš©í•´ì„œ í…ŒìŠ¤íŠ¸í•˜ê¸¸ ì›í•˜ëŠ” ì»¨íŠ¸ë™íŠ¸ë¥¼ êµ¬ì²´í™” í•˜ê³  ë‚˜ë©´ Truffleì€ ìë™ì ìœ¼ë¡œ ìŠ¤ë§ˆíŠ¸ì»¨íŠ¸ë™íŠ¸ì— ì˜í•´ ìƒì„±ëœ logsë¥¼ ì œê³µí•œë‹¤. ì´ ê²ƒì€ ìš°ë¦¬ê°€ ì´ê²ƒì„ ì‚¬ìš©í•˜ë¯€ë¡œì¨ ì•¨ë¦¬ìŠ¤ì˜ ìƒˆë¡­ê²Œ ìƒì„±ëœ ì¢€ë¹„ì˜ ì´ë¦„ì„ ê²€ìƒ‰í•  ìˆ˜ ìˆë‹¤ëŠ” ê²ƒì„ ì˜ë¯¸í•œë‹¤.
    
    ```jsx
    result.logs[0].args.name
    ```
    
    <aside>
    ğŸ’¡ resultëŠ” íŠ¸ëœì­ì…˜ì— ëŒ€í•œ ëª‡ê°€ì§€ ë‹¤ë¥¸ ìœ ìš©í•œ ì„¤ëª…ì„ ì œê³µí•œë‹¤.
    - result.tx : íŠ¸ëœì­ì…˜ í•´ì‹œ
    - result.receipt : íŠ¸ëœì­ì…˜ receiptë¥¼ í¬í•¨í•œ ê°ì²´ (ë§Œì•½, result.receipt.statusê°€ trueë¼ë©´ ì´ê²ƒì€ íŠ¸ëœì­ì…˜ì´ ì„±ê³µì ìœ¼ë¡œ ìˆ˜í–‰ë˜ì—ˆìŒì„ ì˜ë¯¸í•˜ê³  ê·¸ë ‡ì§€ ì•Šìœ¼ë©´ ì‹¤íŒ¨í–ˆìŒì„ ì˜ë¯¸í•¨)
    
    </aside>
    
    <aside>
    ğŸ’¡ logsëŠ” ë˜í•œ ë°ì´í„°ë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ í›¨ì”¬ ì €ë ´í•œ ì˜µì…˜ìœ¼ë¡œì¨ ì‚¬ìš©ë¨. ë‹¨ì ì€ ìŠ¤ë§ˆíŠ¸ì»¨íŠ¸ë™íŠ¸ ì•ˆì—ì„œëŠ” ì ‘ê·¼ í•  ìˆ˜ ì—†ë‹¤ëŠ” ê²ƒ
    
    </aside>
    
- Assert

ì´ ì±•í„°ì•ˆì—ì„œëŠ” built-in assertion moduleì¸ equal()ê³¼ deepEqual()ì„ ì‚¬ìš©.

ì´ í•¨ìˆ˜ë“¤ì€ conditionì„ ì²´í¬í•˜ê³  ë§Œì•½ resultê°€ ë‹¤ë¥´ë‹¤ë©´ errorë¥¼ ë˜ì§. ê°’ì„ ê°„ë‹¨íˆ ë¹„êµí• ë•ŒëŠ” ë³´í†µ assert.equal()ì„ ì‚¬ìš©

- Hooks

<aside>
ğŸ’¡ í›„í‚¹ì€ ì†Œí”„íŠ¸ì›¨ì–´ ê³µí•™ ìš©ì–´ë¡œ, ìš´ì˜ ì²´ì œë‚˜ ì‘ìš© ì†Œí”„íŠ¸ì›¨ì–´ ë“±ì˜ ê°ì¢… ì»´í“¨í„° í”„ë¡œê·¸ë¨ì—ì„œ ì†Œí”„íŠ¸ì›¨ì–´ êµ¬ì„± ìš”ì†Œ ê°„ì— ë°œìƒí•˜ëŠ” í•¨ìˆ˜ í˜¸ì¶œ, ë©”ì‹œì§€, ì´ë²¤íŠ¸ ë“±ì„ ì¤‘ê°„ì—ì„œ ë°”ê¾¸ê±°ë‚˜ ê°€ë¡œì±„ëŠ” ëª…ë ¹, ë°©ë²•, ê¸°ìˆ ì´ë‚˜ í–‰ìœ„ë¥¼ ë§í•œë‹¤

</aside>

í•˜ë‚˜ ì´ìƒì˜ í…ŒìŠ¤íŠ¸ë¥¼ í•˜ê¸°ìœ„í•´ ê° í…ŒìŠ¤íŠ¸ëŠ” clean sheetì— ì‹œì‘í•˜ëŠ”ê²ƒì´ ì¢‹ìŒ. ë”°ë¼ì„œ ëª¨ë“  ë‹¨ì¼ í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ ë‹¤ìŒê³¼ê°™ì´ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì˜ ìƒˆë¡œìš´ ì¸ìŠ¤í„´ìŠ¤ë¥¼ ìƒì„±í•´ ì£¼ì–´ì•¼ í•œë‹¤.

```jsx
const contractInstance = await CryptoZombies.new();
```

 

<aside>
ğŸ’¡ ë§Œì•½, ì´ê²ƒì„ í•œë²ˆë§Œ ì“°ê±°ë‚˜ Truffleì´ ëª¨ë“  í…ŒìŠ¤íŠ¸ë§ˆë‹¤ ê·¸ê²ƒì„ ìë™ì ìœ¼ë¡œ runí•˜ë„ë¡ í•˜ëŠ”ê²ƒì€ ì¢‹ì€ ë°©ë²•ì¼ê¹Œ?

Mochaì™€ Truffleì˜ íŠ¹ì§• ì¤‘ í•˜ë‚˜ëŠ” í…ŒìŠ¤íŠ¸ ì „ í›„ë¡œ hookì´ë¼ê³  ë¶ˆë¦¬ëŠ” snippets of code, ì¦‰ ì¬ì‚¬ìš© ê°€ëŠ¥í•œ ì½”ë“œë¥¼ ëŒë¦¬ëŠ” ëŠ¥ë ¥ì´ ìˆë‹¤ëŠ” ê²ƒ.
í…ŒìŠ¤íŠ¸ê°€ ì‹¤í–‰ë˜ì „ì— ë¬´ì–¸ê°€ë¥¼ runí•˜ê¸° ìœ„í•œ ì½”ë“œëŠ” beforeEach()ë¼ëŠ” ì´ë¦„ì˜ í•¨ìˆ˜ ë‚´ë¶€ì— ë†“ì—¬ì ¸ì•¼ í•¨. 

ë”°ë¼ì„œ contract.new()ë¥¼ ëª‡ë²ˆì”© ì“°ëŠ” ëŒ€ì‹ ì— ì•„ë˜ì™€ ê°™ì´ í•œë²ˆë§Œ ì“¸ ìˆ˜ ìˆìŒ.

</aside>

```jsx
beforEach(async () => {
	// let's the put here the code that creates a new contract instance
});
```

 â‡’ ê·¸ëŸ¬ë©´ Truffleì´ ëª¨ë“ ê²ƒì„ ìˆ˜í–‰í•¨.

- Zombie Transfers

ì•¨ë¦¬ìŠ¤ê°€ ì¢€ë¹„ë¥¼ ë°¥ì—ê²Œ ë³´ë‚´ë ¤ê³  í•¨

â‡’ ì—¬ê¸°ì„œ ì¢€ë¹„ëŠ” ERC721ì„ ìƒì†ë°›ê¸° ë•Œë¬¸ì— 2ê°€ì§€ ë°©ì‹ìœ¼ë¡œ í† í°ì„ ì „ì†¡í•  ìˆ˜ ìˆìŒ.

1. 

```jsx
function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
```

â‡’ ì•¨ë¦¬ìŠ¤(the owner)ëŠ” _from ì¸ìë¡œì„œ ê·¸ë…€ì˜ ì£¼ì†Œ, _toì˜ ì¸ìë¡œì„œ ë°¥ì˜ ì£¼ì†Œ, ê·¸ë…€ê°€ ì „ì†¡í•  zombieIdì™€ í•¨ê»˜ transferFromì„ ë¶€ë¦„

1. 

```jsx
function approve(address _approved, uint256 _tokenId) external payable;
```

followed by

```jsx
function transferFrom(address _from, address _to, uint256 _tokenId) external payable;
```

â‡’ ì•¨ë¦¬ìŠ¤ê°€ ì²˜ìŒì— ë°¥ì˜ ì£¼ì†Œì™€ zombieIdì™€ í•¨ê»˜ approveë¥¼ ë¶€ë¦„. ê·¸ëŸ¬ë©´ ë°¥ì„ ì €ì¥í•œ ì»¨íŠ¸ë™íŠ¸ëŠ” ì¢€ë¹„ ê°–ë„ë¡ ìŠ¹ì¸ë°›ìŒ. ê·¸ë¦¬ê³ ë‚˜ì„œ ì•¨ë¦¬ìŠ¤ ë˜ëŠ” ë°¥ì´ transferFromì„ ë¶€ë¥´ë©´ ì»¨íŠ¸ë™íŠ¸ëŠ” msg.senderê°€ ì•¨ë¦¬ìŠ¤ ë˜ëŠ” ë°¥ì˜ ì£¼ì†Œê°€ ë§ëŠ”ì§€ í™•ì¸í•¨. ë§Œì•½ ë§ë‹¤ë©´ ì¢€ë¹„ë¥¼ ë°¥ì—ì„œ ì „ì†¡

 ì´ ë‘ê°€ì§€ ë°©ì‹ì„ ì¢€ë¹„ë¥¼ ì „ì†¡í•˜ëŠ” ì‹œë‚˜ë¦¬ì˜¤ ë¼ê³  ë¶€ë¦„.

ì´ ê°ê°ì˜ ì‹œë‚˜ë¦¬ì˜¤ë¥¼ í…ŒìŠ¤íŠ¸ í•˜ê¸° ìœ„í•´, ë‘ê°œì˜ ë‹¤ë¥¸ í…ŒìŠ¤íŠ¸ ê·¸ë£¹ì„ ë§Œë“¤ê³  ê·¸ê²ƒë“¤ì— ì˜ë¯¸ìˆëŠ” ì„¤ëª…ì„ ì£¼ì–´ì•¼í•¨.

<aside>
ğŸ’¡ ì™œ ê·¸ë£¹ì„ ì§“ëŠ”ì§€?
ë‘ë²ˆì§¸ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ approve ë’¤ì— transferFromì„ í•˜ëŠ”ê²ƒì€  ìµœì†Œ ë‘ê°œì˜ í…ŒìŠ¤íŠ¸ë¥¼ ìš”êµ¬í•¨
1. ì•¨ë¦¬ìŠ¤ê°€ ì¢€ë¹„ë¥¼ ì „ì†¡ í•  ìˆ˜ ìˆëŠ”ì§€ ë°˜ë“œì‹œ ì²´í¬
2. ë°¥ì´ transferFromì„ runí•  ìˆ˜ ìˆëŠ”ì§€ ì²´í¬

</aside>

- The context function

í…ŒìŠ¤íŠ¸ë¥¼ ê·¸ë£¹í•‘í•˜ê¸° ìœ„í•´, Truffleì€ contextë¼ê³  ë¶ˆë¦¬ëŠ” í•¨ìˆ˜ë¥¼ ì œê³µí•¨.

```jsx
context("with the single-step transfer scenario", async () => {
    it("should transfer a zombie", async () => {
      // TODO: Test the single-step transfer scenario.
    })
})

context("with the two-step transfer scenario", async () => {
    it("should approve and then transfer a zombie when the approved address calls transferFrom", async () => {
      // TODO: Test the two-step scenario.  The approved address calls transferFrom
    })
    it("should approve and then transfer a zombie when the owner calls transferFrom", async () => {
        // TODO: Test the two-step scenario.  The owner calls transferFrom
     })
})
```

```jsx
Contract: CryptoZombies
    âœ“ should be able to create a new zombie (100ms)
    âœ“ should not allow two zombies (251ms)
    with the single-step transfer scenario
      âœ“ should transfer a zombie
    with the two-step transfer scenario
      âœ“ should approve and then transfer a zombie when the owner calls transferFrom
      âœ“ should approve and then transfer a zombie when the approved address calls transferFrom

  5 passing (2s)
```

â‡’ ëª¨ë“  í…ŒìŠ¤íŠ¸ ì‹¤í–‰

<aside>
ğŸ’¡ context(), it()ë“± í•¨ìˆ˜ ì•ì— xë¥¼ ë¶™ì´ë©´ Truffledì€ ê·¸ í…ŒìŠ¤íŠ¸ë¥¼ ê±´ë„ˆ ëœ€.
ì˜ˆ) xcontext(), xit()

ë˜ëŠ” skip()ì„ í•¨ìˆ˜ ë’¤ì— ë¶™ì„ 
ì˜ˆ)it.skip()

</aside>

```jsx
Contract: CryptoZombies
    âœ“ should be able to create a new zombie (199ms)
    âœ“ should not allow two zombies (175ms)
    with the single-step transfer scenario
      - should transfer a zombie
    with the two-step transfer scenario
      - should approve and then transfer a zombie when the owner calls transferFrom
      - should approve and then transfer a zombie when the approved address calls transferFrom

  2 passing (827ms)
  3 pending
```

â‡’ â€œ-â€ëŠ” xê°€ ë¶™ì€ í•¨ìˆ˜ë¥¼ ê±´ë„ˆë›°ì–´ í…ŒìŠ¤íŠ¸ë¥¼ í•˜ì§€ ì•Šì€ í…ŒìŠ¤íŠ¸ë¥¼ ë‚˜íƒ€ëƒ„

- Time Travelling

GanacheëŠ” ë‹¤ìŒ ë‘ê°€ì§€ì˜ helper functionsë¥¼ í†µí•´ì„œ ì‹œê°„ì„ ì›€ì§ì´ëŠ” ë°©ë²•ì„ ì œê³µí•¨

1. evm_increaseTime : ë‹¤ìŒë¸”ë¡ì˜ ì‹œê°„ì„ ì¦ê°€ì‹œí‚´
2. evm_mine : ìƒˆë¡œìš´ ë¸”ë¡ì„ ì±„êµ´

<aside>
ğŸ’¡ ì´ëŸ¬í•œ í•¨ìˆ˜ë“¤ì´ ì–´ë–»ê²Œ ì‘ë™í•˜ëŠ”ì§€?
- ìƒˆë¡œìš´ ë¸”ë¡ì„ ì–»ì„ ë•Œ ë§ˆë‹¤, ì±„êµ´ìëŠ” ê·¸ê²ƒì— timestampë¥¼ ì¶”ê°€í•œë‹¤. (ì¢€ë¹„ë¥¼ ìƒì„±í•˜ëŠ” íŠ¸ëœì­ì…˜ì´ ë¸”ë¡5ë²ˆì— í¬í•¨ë˜ì–´ìˆë‹¤ê³  ê°€ì •í•˜ì)
ê·¸ í›„, evm_increaseTime ì„ call í•˜ì§€ë§Œ ë¸”ë¡ì²´ì¸ì´ ë¶ˆë³€í•˜ê³  ì¡´ì¬í•˜ëŠ” ë¸”ë¡ì„ ìˆ˜ì •í•  ë°©ë²•ì´ ì—†ê¸°ë•Œë¬¸ì— ì»¨íŠ¸ë™íŠ¸ê°€ ì‹œê°„ì„ ì²´í¬í• ë•Œ, ì‹œê°„ì„ ì¦ê°€ì‹œí‚¬ ìˆ˜ ì—†ë‹¤.

ë§Œì•½ evm_mineì„ runí•˜ë©´, ë¸”ë¡6ë²ˆì´ ì±„êµ´ë˜ë©´ì„œ timestampedë˜ê³  ê·¸ê²ƒì€ ì¢€ë¹„ê°€ ì‹¸ìš¸ ë•Œ, ìŠ¤ë§ˆíŠ¸ì»¨íŠ¸ë™íŠ¸ê°€ í•˜ë£¨ê°€ ì§€ë‚œ ê²ƒì„ ì˜ë¯¸í•œë‹¤.

</aside>

```jsx
await web3.currentProvider.sendAsync({
  jsonrpc: "2.0",
  method: "evm_increaseTime",
  params: [86400],  // there are 86400 seconds in a day
  id: new Date().getTime()
}, () => { });

web3.currentProvider.send({
    jsonrpc: '2.0',
    method: 'evm_mine',
    params: [],
    id: new Date().getTime()
});
```

```jsx
time.increaseTime(86400);

//or

await time.increase(time.duration.days(1))
```

â‡’ ë‹¹ì—°í•˜ê²Œë„, time travelingì€ main ent ë˜ëŠ” ì±„êµ´ìì— ì˜í•´ ë³´ì•ˆëœ ì–´ë–¤ ì´ìš©ê°€ëŠ¥í•œ í…ŒìŠ¤íŠ¸ ì²´ì¸ì½”ë“œì—ì„œë„ ì‚¬ìš©í•  ìˆ˜ ì—†ìŒ. ìŠ¤ë§ˆíŠ¸ì»¨íŠ¸ë™íŠ¸ í…ŒìŠ¤íŠ¸ë¥¼ ìœ„í•´ì„œë§Œ ì‚¬ìš©ë  ìˆ˜ ìˆìŒ.

- More Expressive Assertions with Chai

build-in assert moduleì€ ì½”ë“œ ê°€ë…ì„±ì´ ë–¨ì–´ì§ â‡’ ëª‡ëª‡ì˜ ë” ë‚˜ì€ assertion modules ê°€ ìˆëŠ”ë° ê·¸ ì¤‘ ì œì¼ ì¢‹ì€ê²ƒì´ Chai

- Chai Assertion Library
    
    â‡’ Chaiì˜ 3ê°€ì§€ assertion styles
    
    - expect : lets you chain natural language assertion as follow
    
    ```jsx
    let lessonTitle = "Testing Smart Contracts with Truffle";
    expect(lessonTitle).to.be.a("string");
    ```
    
    - should : allows for similar assertions as expect interface, but the chain starts with a should property
    
    ```jsx
    let lessonTitle = "Testing Smart Contracts with Truffle";
    lessonTitle.should.be.a("string");
    ```
    
    - assert : provides a notation similar to that packaged with node.js and includes several additional tests and itâ€™s browser compatible
    
    ```jsx
    let lessonTitle = "Testing smart Contracts with Truffle";
    assert.typeOf(lessonTitle, "string");
    ```
    
    -npm ì„¤ì¹˜
    
    ```powershell
    npm -g install chai
    ```
    
    -expect styleì„ ì‚¬ìš©í•˜ê¸° ìœ„í•´ ì½”ë“œ ì¶”ê°€
    
    ```powershell
    var expect = require('chai').expect;
    ```
    
    ì˜ˆì‹œ ì½”ë“œ)
    
    ```jsx
    let zombieName = 'My Awesome Zombie';
    expect(zombieName).to.equal('My Awesome Zombie');
    ```