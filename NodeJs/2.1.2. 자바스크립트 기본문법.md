# 2.1.2 자바스크립트 기본 문법

## < 함수, 프로토타입과 상속 >

<hr>

## 함수
<br>

[sample10.js] 함수의 선언
```javascript
function add(a,b) {
    return a + b;
}

console.log(add(1,4)); //5
```
함수를 만들려면 다른 언어와 비슷하게 `function`을 통해 선언하고, `()` 안에 파라미터를 지정하고, `{}`문 안에 로직을 작성하고, `return`을 통해 반환 값(결과 값)을 저장할 수 있음   
<br>


[sample11.js] 화살표 함수의 선언
```javascript
const add = (a, b) => {
    return a + b;
}

console.log(add(1,4)); //5
```
함수를 `function` 대신 화살표 함수인 `=>`를 통해 선언할 수 있음
> `=>` ES6부터 도입된 화살표 함수로, 흔히 ***람다식***이라고 함   

<br>

const add = (a, b) => a + b;

함수 내에 return 밖에 없다면 위 소스처럼 줄여서 쓸 수 있음   

<hr>

### 화살표 함수의 중요한 특징
: ① 함수명, ② arguments, ③ this, 이 세가지가 없다는 점   
→ 함수명이 없다는 것 : *익명 함수*로 동작한다는 뜻   

→ arguments가 없다는 것    

```javascript
const func = function () {
    console. log(arguments);
}

func(1,2,3,4); // [Arguments] { '0': 1, '1': 2, '2': 3, '3': 4}
```

보통 함수가 생성되면 자신의 스코프 안에 자기 자신을 가리키 `this`와 파라미터가 담기는 `arguments`가 자동으로 생성 됨

```javascript
const func = (...args) =>  {
    console. log(args);
}

func(1,2,3,4); // [ 1,2,3,4 ]
```
하지만 화살표 함수에는 arguments가 자동으로 생성되지 않기 때문에 arguments가 필요하다면 함수의 파라미터 부분에 `...args`를 넣어 args라는 배열 안에 파라미터를 담을 수 있음. `...`은 전개 연산자라고 하는데, ***"값이 몇 개가 될지 모르나 뒤에 오는 변수명에 값을 배열로 넣어라"*** 라고 하는, ES6이후 추가된 문법 중 하나

→ this가 없다는 것
자바스크립트에서 this는 호출하는 방법에 의해 결정.   
브라우저 콘솔 `console.log(this);`를 찍어보면 결과로 Window 객체가 나오게 됨. `console.log(this);`을 호출한 함수는 전역(Global)이고 브라우저에서 Global은 Window 객체를 의미하기 때문에 이와 같은 결과가 나옴

[sample12.js] this의 사용
```javascript
var people = {
    name: 'gildong',
    say: function() {
        console.log(this);
    }
}

people.say(); // { name: 'gildong' , say : [Function: say] }

var sayPeople = people.say;
sayPeople();
```


[sample12.js 결과]
```
{ name: 'gildong' , say : [Function: say] }
Object [global] {
    global: [Circular],
    clearInterval: [function: clearInterval],
    ...
}
```

people.say()에서는 people 객체가 say()를 호출했으므로 this는 people 객체가 되고, sayPeople 변수에 people.say를 넣고 호출한 경우는 전역 변수 즉, 전역(Global)이 호출한 주체가 되므로 this는 전역(Global)객체가 됨

[sample12-2.js] bind 함수 사용
```javascript
var people = {
    name: 'gildong',
    say: function() {
        console.log(this);
    }
}

people.say(); 

var sayPeople = people.say.bind(people);
sayPeople();
```

[sample12-2.js 결과]
```
{ name: 'gildong' , say : [Function: say] }
{ name: 'gildong' , say : [Function: say] }
```
this를 객체로 고정하고 싶다면 `bind(this로 고정시킬 객체)`함수를 이용함   

하지만 바로 이 this가 존재하지 않으니 화살표 함수에서는 `bind`를 사용해도 this를 주입할 수 없음. 때문에 생성자(new)를 사용해 화살표 함수로 만들어진 객체의 인스턴스를 생성할 수 없음. 만약 화살표 함수로 만들어진 객체에 this를 사용한다면 일반적인 인자나 변수와 동일하게 취급하게 되고 내부 스코프에 this가 없기 때문에 상위 함수의 this나 전역(Global) 객체의 this를 불러오게 됨.

<br>
<hr>

## 프로토타입과 상속

프로토타입(Prototype)은 '원형'인데, 자바스크립트로 객체 지향 프로그래밍을 할 수 있게 도와주는 것   

자바스크립트는 클래스가 없으므로 '프로토타입'을 통해 비슷하게 흉내냄
때문에 자바스크립트는 `객체 지향 언어`라고 하지 않고 `프로토타입 기반 언어`라고 하는 것

[sample13.js] 프로토타입을 이용한 객체 생성
```javascript
function func() { };
console.log(func.prototype); //func {}

func.prototype.name = 'gildong';
console.log(func.prototype); //func { name: 'gildong'}
```

자바스크립트에서 기본 데이터 타입을 제외한 모든 것이 객체인데, 이 객체의 '원형'인 프로토타입을 이용해서 새로운 객체를 만들어내고 이렇게 생성된 객체는 또 다른 객체의 원형이 되어 새로운 객체를 만들어낼 수 있음. prototype은 객체의 프로퍼티 중 용도가 약속되어 있는 특수한 프로퍼티이고 이 역시도 객체임.

